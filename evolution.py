import events
import pygame
import numpy as np
import copy

from game import GameWrapper
from network import Network


class BirdEvolution:
    def __init__(self, n_neurons=10):
        self.network = Network(input_size=2, n_neurons=n_neurons)
        self.game = GameWrapper(fps=60, screen_resolution=(3000, 1500))
        self.n_neurons = n_neurons
        self.population = None
        self.is_running = False

    
    def evolve(self, n_generations, pop_size, p_mutation, offspring_size):
        
        self.population = self._init_population(pop_size)

        for i in range(n_generations):
            fitnesses = self._evaluate_population(pop_size)
            offspring = self._create_offspring(fitnesses,  p_mutation, pop_size, offspring_size)
            self._merge_solutions(offspring, fitnesses)

    def _init_population(self, pop_size):
        individual_size = ((2 * self.n_neurons) + (self.n_neurons * 1) + self.n_neurons + 1)
        return np.random.randn(individual_size * pop_size).reshape(pop_size, individual_size)

    def _evaluate_population(self, pop_size):
        if not self.is_running:
            self.game.create_players(pop_size)
            self.game.init()
            self.is_running = True
        else:
            self.game.reset()
            self.game.create_players(pop_size)
        
        is_over = False
        while not is_over:
            is_over, distances = self.game.loop()

            for id, distance in distances:
                self.network.load_weights(self.population[id])
                decision = np.round(self.network.predict(np.array(distance).reshape(1, -1))).astype(int)

                if decision:
                    self.game.add_event(pygame.event.Event(events.MOVEUP_EVENT, id=id))

        return np.array(copy.deepcopy(self.game.player_scores)) # [individual_idx, fitness]
    
    def _create_offspring(self, fitnesses,  p_mutation, pop_size, offspring_size):
        offspring = self._crossover(self._get_parents(fitnesses, offspring_size))
        offspring = self._mutate(offspring, p_mutation)
        return offspring
    
    def _merge_solutions(self, offspring, fitnesses):
        worst_individuals = fitnesses[: offspring.shape[0], 0]
        self.population[worst_individuals] = offspring


    def _crossover(self, parents):
        # 2 - random point crossover
        offspring = []
        for first_parent, second_parent in parents:
            points = np.sort(np.random.randint(1, self.population.shape[1], 2))
            first_parent, second_parent = self.population[first_parent], self.population[second_parent]
            offspring.extend([
                np.array([*first_parent[:points[0]], *second_parent[points[0]: points[1]], *first_parent[points[1]:]]),
                np.array([*second_parent[:points[0]], *first_parent[points[0]: points[1]], *second_parent[points[1]:]])
            ])

        return np.array(offspring)



    def _mutate(self, solutions, p_mutation):
        # Mutations are generated by random normal distribution with mean 0 and std 1
        # Probability of mutation indicates the probability of mutation of one single value in the given solution 
        mutation_mask = np.random.random(np.prod(solutions.shape)).reshape(solutions.shape)
        mutation_mask = (mutation_mask < p_mutation).astype(int)
        mutations = np.random.randn(np.prod(solutions.shape)).reshape(solutions.shape) * mutation_mask
        solutions = solutions + mutations
        return solutions

    def _get_parents(self, fitnesses, offspring_size):
        return fitnesses[-offspring_size:, 0].reshape((offspring_size // 2, 2))
        


bird_evolution = BirdEvolution()
bird_evolution.evolve(100, pop_size=20, p_mutation=0.1, offspring_size=14)


# Initialize population
# Evaluate population (play game until it ends)
# Choose parents
# Create offspring
# Mutate offspring
# Replace the worst part with the offspring


# game = GameWrapper(fps=60, screen_resolution=(3000, 1500))
# players = game.create_players(10)
# game.init()

# is_over = False
# while True:
#     is_over, distances = game.loop()

#     if is_over:
#         print(game.player_score)
#         game.reset()
#         players = game.create_players(10)

