import events
import pygame
import numpy as np
import copy

from game import GameWrapper
from network import Network


class BirdEvolution:
    def __init__(self, n_neurons=10, input_size=3):
        self.network = Network(input_size=3, n_neurons=n_neurons)
        self.game = GameWrapper(fps=120, screen_resolution=(3000, 1500))
        self.n_neurons = n_neurons
        self.input_size = input_size
        self.population = None
        self.is_running = False

    
    def evolve(self, n_generations, pop_size, p_mutation_initial, p_mutation_min, offspring_size, tournament_size=4):
        
        self.population = self._init_population(pop_size)

        for i in range(n_generations):
            fitnesses = self._evaluate_population(pop_size)
            offspring = self._create_offspring(fitnesses,  self._mutation_decay(p_mutation_initial, p_mutation_min, i + 1), pop_size, offspring_size, tournament_size)
            self._merge_solutions(offspring, fitnesses)

    def _init_population(self, pop_size):
        individual_size = ((self.input_size * self.n_neurons) + (self.n_neurons * 1) + self.n_neurons + 1)
        return np.random.randn(individual_size * pop_size).reshape(pop_size, individual_size)

    def _evaluate_population(self, pop_size):
        if not self.is_running:
            self.game.create_players(pop_size)
            self.game.init()
            self.is_running = True
        else:
            self.game.reset()
            self.game.create_players(pop_size)
        
        self.game.stats.generation += 1

        is_over = False
        while not is_over:
            is_over, distances = self.game.loop()

            for id, distance in distances:
                self.network.load_weights(self.population[id])
                decision = np.round(self.network.predict(np.array(distance).reshape(1, -1))).astype(int)

                if decision:
                    self.game.add_event(pygame.event.Event(events.MOVEUP_EVENT, id=id))

        return np.array(copy.deepcopy(self.game.player_scores)) # [individual_idx, fitness]
    
    def _create_offspring(self, fitnesses,  p_mutation, pop_size, offspring_size, tournament_size):
        offspring = self._crossover(self._get_parents(fitnesses, offspring_size, k=tournament_size))
        offspring = self._mutate(offspring, p_mutation)
        return offspring
    
    def _merge_solutions(self, offspring, fitnesses):
        worst_individuals = fitnesses[: offspring.shape[0], 0]
        self.population[worst_individuals] = offspring


    def _crossover(self, parents):
        # 2 - random point crossover
        offspring = []
        for first_parent, second_parent in parents:
            points = np.sort(np.random.randint(1, self.population.shape[1], 2))
            first_parent, second_parent = self.population[first_parent], self.population[second_parent]
            offspring.extend([
                np.array([*first_parent[:points[0]], *second_parent[points[0]: points[1]], *first_parent[points[1]:]]),
                np.array([*second_parent[:points[0]], *first_parent[points[0]: points[1]], *second_parent[points[1]:]])
            ])

        return np.array(offspring)



    def _mutate(self, solutions, p_mutation):
        # Mutations are generated by random normal distribution with mean 0 and std 1
        # Probability of mutation indicates the probability of mutation of one single value in the given solution 
        mutation_mask = np.random.random(np.prod(solutions.shape)).reshape(solutions.shape)
        mutation_mask = (mutation_mask < p_mutation).astype(int)
        mutations = np.random.randn(np.prod(solutions.shape)).reshape(solutions.shape) * mutation_mask
        solutions = solutions + mutations
        return solutions

    def _get_parents(self, fitnesses, offspring_size, selection_type='best', k=4):
        parents = None
        if selection_type == 'tournament':
            parents = self._tournament_selection(fitnesses, offspring_size, k)
        elif selection_type == 'best':
            parents = fitnesses[-offspring_size:, 0].reshape((offspring_size // 2, 2))
        return parents
    
    def _tournament_selection(self, fitnesses, offspring_size, k):
        fitnesses = fitnesses[np.argsort(fitnesses[:, 0])]
        tournaments = np.random.randint(0, self.population.shape[0], size=offspring_size * k).reshape((offspring_size, k))
        winners = []
        for tournament in tournaments:
            winners.append(tournament[np.argmax(fitnesses[tournament, 1])])

        return np.array(winners).reshape(offspring_size // 2, 2)

    def _mutation_decay(self, p_initial, p_min, gen):
        return max(p_initial / gen, p_min)
        
